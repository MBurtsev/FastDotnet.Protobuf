### FastDotnet.Protobuf (vendored fork)

This directory contains a **vendored fork** of Google's Protocol Buffers implementation, adapted for **high-throughput .NET workloads** (low allocations, pooling, faster parsing/writing) and for **custom code generation** used by this repository.

- **Original repository**: `https://github.com/protocolbuffers/protobuf`

---

## Why we forked

In this project we needed:

- **Zero allocations** in hot paths (market data, trading loops)
- **Object pooling** for protobuf DTOs (`Rent()/Return()`)
- **Pool protection** for async scenarios (logging, multiple consumers)
- A **very small and fast** reader/writer tailored to our generated DTOs
- **Allocation-free logging** via `ToLog(StringBuilder)` method
- A build flow where protobuf DTOs are generated by **our own generator** (instead of `Grpc.Tools` C# output)

---

## Key Features

### 1. Object Pooling

All generated message classes inherit from `PooledObjectBase` and use a static `ObjectPool<T>` for zero-allocation reuse:

```csharp
// Rent from pool (zero allocation after warmup)
var request = MyRequest.Rent();
request.AccountId = "123";

// Use the message...
await client.CallAsync(request);

// Return to pool for reuse
request.Return();
```

### 2. Pool Protection (PoolProtect)

When an object needs to be consumed by **multiple parts of the system** before returning to pool (e.g., async logging + caller), use `PoolProtectOneTime()`:

```csharp
// Caller receives response from gRPC
var response = await client.GetDataAsync();

// Logger needs to read data asynchronously
response.PoolProtectOneTime();  // _isInPool becomes -1

logger.Info(sb => {
    // Safe to read — object is protected
    sb.Append(response.Data);
    
    // First Return: _isInPool becomes 0, NOT returned to pool yet
    response.Return();
});

// Caller finishes using response
// Second Return: _isInPool is 0, NOW returned to pool
response.Return();
```

For multiple consumers, use `PoolProtect(int times)`:

```csharp
response.PoolProtect(3);  // Allow 3 extra Return() calls

// Consumer 1
ProcessAsync(response).ContinueWith(_ => response.Return());

// Consumer 2  
LogAsync(response).ContinueWith(_ => response.Return());

// Consumer 3
MetricsAsync(response).ContinueWith(_ => response.Return());

// Original caller
response.Return();  // 4th Return — actually returns to pool
```

### 3. SerializedSize Tracking

After deserialization, `SerializedSize` contains the byte count of the message:

```csharp
var response = MyResponse.Rent();
response.MergeFrom(ref reader);

Console.WriteLine($"Received {response.SerializedSize} bytes");
```

### 4. Allocation-Free Logging

Each message has a `ToLog(StringBuilder)` method for zero-allocation logging:

```csharp
logger.Info(sb => {
    sb.Append("Response: ");
    response.ToLog(sb);  // Appends: { Field1: "value", Field2: 123, ... }
});
```

Output format:
```
{ AccountId: "123", Balance: 1000.50, Positions: [3] }
```

### 5. Fast Serialization

No reflection, no boxing — direct field access:

```csharp
// Write
var writer = new ProtoWriter(bufferWriter);
message.WriteTo(ref writer);
writer.Flush();

// Read
var reader = new ProtoReader(span);
message.MergeFrom(ref reader);
```

---

## Architecture

### PooledObjectBase

Abstract base class for all pooled messages:

```csharp
public abstract class PooledObjectBase
{
    // Pool state (negative = protected, 0 = ready to return, 1 = in pool)
    internal int _isInPool;
    
    // Size in bytes after deserialization
    public int SerializedSize;
    
    // Protect from next N Return() calls
    public void PoolProtectOneTime();
    public void PoolProtect(int times);
    
    // Abstract methods (implemented by generated classes)
    public abstract void Clear();
    public abstract void WriteTo(ref ProtoWriter writer);
    public abstract void MergeFrom(ref ProtoReader reader);
    public abstract void ToLog(StringBuilder sb);
    public abstract void Return();
}
```

### ObjectPool<T>

Thread-safe, lock-free pool using `ConcurrentQueue<T>`:

```csharp
public class ObjectPool<T> where T : PooledObjectBase, new()
{
    public T Rent();           // Get from pool or create new
    public void Return(T obj); // Clear and return to pool
}
```

The `Return()` method handles pool protection:
- If `_isInPool < 0`: increment counter, don't return yet
- If `_isInPool == 0`: clear object and enqueue to pool
- If `_isInPool == 1`: already in pool (double-return protection)

---

## Generated Code Structure

For a proto message like:

```protobuf
message GetPositionsRequest {
    string account_id = 1;
}
```

The generator produces:

```csharp
public sealed partial class GetPositionsRequest : PooledObjectBase
{
    static readonly ObjectPool<GetPositionsRequest> s_pool = new(capacity: 64);
    
    public static GetPositionsRequest Rent() => s_pool.Rent();
    public override void Return() => s_pool.Return(this);
    
    public string AccountId { get; set; } = "";
    
    public override void Clear()
    {
        AccountId = "";
    }
    
    public override void WriteTo(ref ProtoWriter writer)
    {
        if (AccountId.Length > 0)
            writer.WriteString(1, AccountId);
    }
    
    public override void MergeFrom(ref ProtoReader reader)
    {
        while (reader.ReadTag() is var tag && tag != 0)
        {
            switch (tag)
            {
                case 10: AccountId = reader.ReadString(); break;
                default: reader.SkipField(tag); break;
            }
        }
    }
    
    public override void ToLog(StringBuilder sb)
    {
        sb.Append("{ AccountId: \"");
        sb.Append(AccountId);
        sb.Append("\" }");
    }
}
```

---

## Usage with gRPC

### Custom Marshaller

```csharp
public static class GrpcFastMarshaller
{
    public static Marshaller<T> Create<T>() where T : PooledObjectBase, new()
    {
        return new Marshaller<T>(
            serializer: (message, context) =>
            {
                var writer = new ProtoWriter(context.GetBufferWriter());
                message.WriteTo(ref writer);
                writer.Flush();
                context.Complete();
            },
            deserializer: context =>
            {
                var message = ObjectPool<T>.Shared.Rent();
                var reader = new ProtoReader(context.PayloadAsReadOnlySequence());
                message.MergeFrom(ref reader);
                message.SerializedSize = (int)context.PayloadLength;
                return message;
            }
        );
    }
}
```

### Logging Interceptor Integration

```csharp
public class GrpcLoggingInterceptor : Interceptor
{
    public override AsyncUnaryCall<TResponse> AsyncUnaryCall<TRequest, TResponse>(...)
    {
        // Log request
        _logger.LogRequest((PooledObjectBase)(object)request);
        
        var call = continuation(request, context);
        
        return new AsyncUnaryCall<TResponse>(
            LogResponseAsync(call.ResponseAsync),
            ...
        );
    }
    
    async Task<TResponse> LogResponseAsync<TResponse>(Task<TResponse> task)
    {
        var response = await task;
        var pooled = (PooledObjectBase)(object)response;
        
        // Protect so logger can read after caller's Return()
        pooled.PoolProtectOneTime();
        
        _logger.Info(sb => {
            sb.Append("Response: ");
            pooled.ToLog(sb);
            pooled.Return();  // Logger's return
        });
        
        return response;  // Caller will call Return() later
    }
}
```

---

## Repository Structure

```
third_party/FastDotnet.Protobuf/
├── csharp/src/
│   ├── Google.Protobuf/
│   │   └── Fast/
│   │       ├── Pooling/
│   │       │   ├── PooledObjectBase.cs   # Base class for messages
│   │       │   └── ObjectPool.cs         # Thread-safe pool
│   │       └── Proto/
│   │           ├── ProtoReader.cs        # Fast deserializer
│   │           ├── ProtoWriter.cs        # Fast serializer
│   │           └── FastMessageCodec.cs   # Nested message helpers
│   │
│   └── FastDotnet.Protobuf.CodeGen/
│       └── Program.cs                    # Code generator
```

---

## Build & Generate

### 1. Generate descriptor set with protoc

```bash
protoc --descriptor_set_out=descriptor_set.pb \
       --include_imports \
       --proto_path=./protos \
       ./protos/**/*.proto
```

### 2. Run the code generator

```bash
dotnet run --project third_party/FastDotnet.Protobuf/csharp/src/FastDotnet.Protobuf.CodeGen \
    -- descriptor_set.pb output_dir MyNamespace --all
```

### 3. MSBuild integration

Add to your `.csproj`:

```xml
<Target Name="GenerateProto" BeforeTargets="BeforeCompile">
    <Exec Command="protoc --descriptor_set_out=$(IntermediateOutputPath)descriptor.pb ..." />
    <Exec Command="dotnet run --project $(SolutionDir)third_party/.../CodeGen.csproj -- ..." />
</Target>
```

---

## Performance Characteristics

| Operation | Standard protobuf-net | FastDotnet.Protobuf |
|-----------|----------------------|---------------------|
| Message allocation | `new()` every time | Pool rent (zero alloc) |
| Serialization | Reflection-based | Direct field access |
| Logging | String allocation | StringBuilder append |
| Multi-consumer | Not supported | PoolProtect() |

### Memory pressure comparison

```
Scenario: 10,000 gRPC calls/sec for 60 seconds

Standard: ~600,000 allocations, ~50MB GC pressure
FastDotnet: ~64 allocations (pool warmup), ~0MB GC pressure
```

---

## Notes

- This is a **vendored dependency for this repository**, not a general-purpose distribution.
- Update/merge from upstream only when needed and after verifying performance + API compatibility.
- The `IFastMessage` interface has been removed — all functionality is now in `PooledObjectBase`.
